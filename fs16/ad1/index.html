<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Robin Suter">
  
  <title>AD1 - HSR Notizen</title>
  

  <link rel="shortcut icon" href="../../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  <link href="../../extra.css" rel="stylesheet">

  
  <script>
    // Current page data
    var mkdocs_page_name = "AD1";
    var mkdocs_page_input_path = "fs16/ad1.md";
    var mkdocs_page_url = "/fs16/ad1/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script>
  <script src="../../js/theme.js"></script> 
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> HSR Notizen</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>FS16</span></li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">AD1</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#algorithmen-und-datenstrukturen">Algorithmen und Datenstrukturen</a></li>
                
                    <li><a class="toctree-l4" href="#prufungsinfo">Prüfungsinfo</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-1-intro-oo-design">Vorlesung 1 - Intro / OO-Design</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-2-arrays-linkedlists-analyse-von-algorithmen">Vorlesung 2 - Arrays / LinkedLists / Analyse von Algorithmen</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-3-algorithm-analysis-rekursion">Vorlesung 3 - Algorithm Analysis / Rekursion</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-4-rekursion">Vorlesung 4 - Rekursion</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-5-rekursion-ii">Vorlesung 5 - Rekursion II</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-6-stacks">Vorlesung 6 - Stacks</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-7-queues">Vorlesung 7 - Queues</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-8-lists-1">Vorlesung 8 - Lists (1)</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-9-lists-trees">Vorlesung 9 - Lists &amp; Trees</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-10-iteratoren-trees">Vorlesung 10 - Iteratoren &amp; Trees</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-11-trees-priority-queues">Vorlesung 11 - Trees &amp; Priority Queues</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-12-heaps-adaptable-pq">Vorlesung 12 - Heaps &amp; Adaptable PQ</a></li>
                
                    <li><a class="toctree-l4" href="#vorlesung-13-maps-hash-tables">Vorlesung 13 - Maps &amp; Hash-Tables</a></li>
                
            
            </ul>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../an2/">An2</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../autospr/">AutoSpr</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../bsys2/">Bsys2</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../exev/">ExEv</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../infsi1/">InfSi1</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../rki/">RKI</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../tecbec/">TecBEC</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../wed1/">WED1</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../playground/">Playground</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">HSR Notizen</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>FS16 &raquo;</li>
        
      
    
    <li>AD1</li>
    <li class="wy-breadcrumbs-aside">
      
        
          <a href="https://github.com/Excape/hsr-docs" class="icon icon-github"> Edit on GitHub</a>
        
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="algorithmen-und-datenstrukturen">Algorithmen und Datenstrukturen</h1>
<h2 id="prufungsinfo">Prüfungsinfo</h2>
<ul>
<li>Alle Papier-Unterlagen erlaubt</li>
<li>Bleistift erlaubt (empfohlen für Zeichnungen)</li>
<li>90 Min</li>
<li>Stoff: Vorlesung + Übungen ohne JUnit</li>
<li>Einzelheiten: Siehe Titelblatt</li>
</ul>
<hr />
<h2 id="vorlesung-1-intro-oo-design">Vorlesung 1 - Intro / OO-Design</h2>
<ul>
<li>
<p>Error-Left<br />
    Error-Zeitpunkte: Compilation, Linking, Runtime<br />
    Ziel: zb. von Runtime zu Compilation Errors, zb. bei Generics: Vorher Runtime-Fehler, mit Generics Compilation-Errors</p>
</li>
<li>
<p>Folie 7: Divide-and-conquer:
    Problem in einzelne Teilprobleme teilen und diese einzeln lösen</p>
</li>
</ul>
<hr />
<h2 id="vorlesung-2-arrays-linkedlists-analyse-von-algorithmen">Vorlesung 2 - Arrays / LinkedLists / Analyse von Algorithmen</h2>
<ul>
<li>
<p>Arrays<br />
    + Schneller Zugriff (bei random access)<br />
    - Feste Grösse</p>
</li>
<li>
<p>Singly-Linked vs Doubly-Linked List<br />
    - Im schlimmsten Fall braucht es nur halb so viel Such-Operationen bei der Doubly-linked-List (wenn Element in der Mitte)</p>
</li>
</ul>
<hr />
<h2 id="vorlesung-3-algorithm-analysis-rekursion">Vorlesung 3 - Algorithm Analysis / Rekursion</h2>
<ul>
<li>
<p>Folie 30:<br />
    Big-Omega ist die Umkehrung von O(n): f(n) &gt;= c * g(n)<br />
    big-Theta: "Bandbreite", in der Komplexität ist</p>
</li>
<li>
<p>Folie 31:<br />
    Asympotisch: Für sehr grosse zahlen</p>
</li>
</ul>
<h3 id="rekursion">Rekursion</h3>
<ul>
<li>
<p>Stack-Size ist in der JVM standardmässig 1MB, kann aber angepasst werden unter Run Configuration - Java-Argument: "-Xss2m" für 2 MB Stack-size</p>
</li>
<li>
<p>Folie 12<br />
    Bei n=123 ist Ausgabe "321"</p>
</li>
<li>
<p>Design-pattern  Adapter:</p>
<ol>
<li>Variante: Komposition: Interface implementieren, bestehende Klasse verwenden (Wrapper)</li>
<li>Variante: Vererbung: Ein Interface implementieren und bestehende Klasse vererben (Klassen-Adapter)</li>
</ol>
</li>
</ul>
<hr />
<h2 id="vorlesung-4-rekursion">Vorlesung 4 - Rekursion</h2>
<ul>
<li>
<p>Folie 28:<br />
<strong>Vorteil</strong> von Klassen-Adapter hier: Weniger "boiler-plate" code, Methoden wie "size()" müssen nicht neu implementiert werden<br />
    Grosser <strong>Nachteil</strong>: Alle Methoden von Vector werden geerbt, also auch solche, die eigentlich nicht zu einem Stack gehören dürfen (zb. set(), removeElementAt(), ...)</p>
</li>
<li>
<p>Objekt-Adapter für robuste Software</p>
</li>
<li>
<p>Klassen-Adapter ist schneller (weniger boiler-plate), dafür hat man mehr Kontrolle über die verfügbaren Methoden</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Vererbung wird zu Compile-Time festgelegt, bei der Komposition wird erst zur Runtime das objekt erstellt, es ist also flexibler</p>
</div>
<hr />
<h2 id="vorlesung-5-rekursion-ii">Vorlesung 5 - Rekursion II</h2>
<ul>
<li>
<p>Folie 41:
    Mit diesem Algorithmus gibt es weniger multiplikationen, da nicht von 1 bis n eine Multiplikation gemacht werden muss, sondern n wird jeweils halbiert:
    <script type="math/tex; mode=display">3^9 = 3^6 * 3^6</script>
<script type="math/tex; mode=display">3^{19} = 3 * 3^9 * 3^9</script>
Dies ist <strong>keine</strong> Endrekursion!</p>
</li>
<li>
<p>Folie 50:<br />
    Keine Endrekursion, da das Ergebnis erst beim Stack-Abbau berechnet wird</p>
</li>
<li>
<p>Folie 52:<br />
    Dies ist Endrekursion, da das Ergebnis schon nach dem Aufbau der Rekursion feststeht</p>
</li>
<li>
<p>Folie 66:<br />
    Dies ist <script type="math/tex">O(n)</script>! Weil die Lösungsmenge nicht aufgeteilt wird, sondern nur "divide and conquer" (zb. bei Parallelisierung sinnvoll)<br />
<strong>Keine</strong> Endrekursion<br />
<script type="math/tex">1 + 2 + 4 ... + \frac n4 + \frac n2 + n = 2n -1</script> rekursive Aufrufe</p>
</li>
<li>
<p>Folie 68<br />
    Alternative mit Integer:
    <script type="math/tex; mode=display">floor: \frac n2</script>
<script type="math/tex; mode=display">ceil: \frac n2 + n % 2</script>
</p>
</li>
</ul>
<hr />
<h2 id="vorlesung-6-stacks">Vorlesung 6 - Stacks</h2>
<ul>
<li><strong>Folie 5</strong><ul>
<li>In diesem Beispiel gibt pop() bei leerem Stack <em>null</em> zurück</li>
</ul>
</li>
<li><strong>Folie 6</strong><ul>
<li><em>java.util.Stack<E>.push()</em> gibt das Item gleich wieder zurück</li>
<li>Gibt <em>EmptyStackException</em>, falls Stack leer ist (bei pop() und peek())</li>
</ul>
</li>
<li><strong>Folie 8</strong><ul>
<li>EmptyStackException ist RuntimeException, also <strong>unchecked</strong> (Designfrage)</li>
</ul>
</li>
<li><strong>Folie 11</strong><ul>
<li>PC (Programmzähler) zeigt auf Position nach dem Funktionsaufruf (Rücksprungadresse). Hier zb. zeigt PC = 1 auf die Zeile nach <code>bar (k);</code></li>
</ul>
</li>
<li><strong>Folie 17</strong><ul>
<li>Das gepopte Element wird auf <em>null</em> gesetzt, damit die Referenz entfernt wird und der GC aufräumen kann.</li>
</ul>
</li>
<li><strong>Folie 18</strong><ul>
<li>list.addFirst() ist <script type="math/tex">O(1)</script>, da einfach ein neues Element an den Anfang "gehängt" wird.</li>
<li>Würde das oberste Element als letztes angehängt, wäre es <script type="math/tex">O(n)</script>, da die ganze Liste durchiteriert werden müsste</li>
</ul>
</li>
<li><strong>Folie 31</strong><ul>
<li>Im Java Doc steht, dass statt java.util.Stack besser <em>Deque</em> benutzt werden soll</li>
<li>Problem: Der Stack erbt alle Methoden von <em>Vector</em> und kann somit auch zb. "SetElementAt", also mehr als ein Stack eigentlich können sollte</li>
<li><strong>Merksatz</strong> Design: Wenn B von A erbt, fragen: Ist B auch ein A?</li>
<li>Hier: Ist Stack auch ein Vektor? &lt;- Nein</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-7-queues">Vorlesung 7 - Queues</h2>
<ul>
<li>"DeQueue", "Deque (sprich Decked)": Double ended Queue</li>
<li>Nicht zu verwechseln mit der Operation "Dequeue"!</li>
<li>NodeDequeue: Eine leere Queue hat trailer und header (2 Nodes)<ul>
<li>Muss nicht immer auf null testen, sondern nur, ob man am "Rand" ist</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-8-lists-1">Vorlesung 8 - Lists (1)</h2>
<p>Unterschied zu Qeues:</p>
<ul>
<li>Positionsangabe</li>
<li>
<p>Implementation kann verschieden sein</p>
</li>
<li>
<p><strong>Folie 3</strong></p>
<ul>
<li><code>E set(i, e)</code> gibt das alte Element zurück</li>
<li>Ebenso <code>E remove(i)</code></li>
<li>Fehler in Folie: add(i, e) wirf nur eine Exception wenn <script type="math/tex">i \notin [0, size()]</script>
</li>
</ul>
</li>
<li>
<p><strong>Folie 5</strong></p>
<ul>
<li>Achtung bei <code>set(2, C)</code>, es kann mit set() nichts hinten an der Liste angehängt werden</li>
</ul>
</li>
<li>
<p><strong>Folie 10</strong></p>
<ul>
<li>Dies ist nicht java.util.ArrayList!</li>
<li>Size-Attribut für schnellere Performance</li>
</ul>
</li>
<li><strong>Folie 20</strong><ul>
<li>Für Array-Kopieren <code>java.lang.System.arracopy</code> verwenden (Native C-Funktion)</li>
</ul>
</li>
<li><strong>Folie 23</strong><ul>
<li>k ist die Anzahl Umkopierungen</li>
<li>
<script type="math/tex">n + \frac{c*k*(k+1)}{2}</script> (Arithmetische Reihe)</li>
</ul>
</li>
<li><strong>Folie 25</strong>
<script type="math/tex; mode=display">1 + (c+1) + 2(c+1) + 3(c+1)...</script>
<ul>
<li>
<script type="math/tex">c+1</script> auf <script type="math/tex">c</script> vereinfachen</li>
</ul>
</li>
<li><strong>Folie 26</strong>
<script type="math/tex; mode=display"> 2^{\log(n)+1} = 2^{\log(n)}*2^1 = n\cdot2 </script>
</li>
<li><strong>Folie 30</strong><ul>
<li>Hier wird das Array jeweils um 1.5x vergrössert</li>
<li>Ammortisierungszeit auch <script type="math/tex">\frac{O(n)}n = O(1)</script>
</li>
</ul>
</li>
<li>
<p><strong>Folie 37</strong></p>
<ul>
<li>p, q, r, usw. sind Positions-Objekte, die Zahlen die Inhalte davon (mit <code>Position.getElement()</code> darauf zugreifen)</li>
<li>Vorteil mit Positionsobjekte: Set(), remove() etc. sind <script type="math/tex">O(1)</script>, da nur das Objekt verändert werden muss, nicht durchiteriert bis zur entsprechenden Position in der Liste</li>
</ul>
</li>
<li>
<p><strong>Folie 46</strong></p>
<ul>
<li>trailer und header nodes sind nicht Teil der liste, es werden nur die Elemente dazwischen zurück gegeben</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-9-lists-trees">Vorlesung 9 - Lists &amp; Trees</h2>
<h3 id="lists">Lists</h3>
<ul>
<li>
<p><strong>Folie 50</strong></p>
<ul>
<li>addBetween() ist eine private Method</li>
<li>Weil node davor und danach stimmen muss; gefährlich, wenn Klasse public wäre</li>
</ul>
</li>
<li>
<p>Das Position Interface wird verwendet, damit für den Benutzer nur <code>getElement()</code> exposed wird, und nicht Node-Operationen wie <code>getNext()</code> oder <code>getPrevious()</code>. So wird die interne Struktur isoliert</p>
</li>
<li>
<p><code>validate()</code> stellt sicher, dass die Position eine Node ist und noch in der Liste ist (noch ein <code>next</code> hat). Voraussetzung ist, dass die Referenzen bei remove() aus der Liste auf null gesetzt werden.</p>
</li>
<li>
<p><strong>Folie 61</strong></p>
<ul>
<li>Hier ist die Liste "zirkulär", d.h wenn mit header.getNext() durchiteriert wird, landet man irgendwann wieder auf dem header (darum der for-loop dementsprechend)</li>
</ul>
</li>
<li>
<p><strong>Folie 63</strong></p>
<ul>
<li>Aus Performance-Gründen. Die Methoden werden für die entsprechenden Datenstrukturen optimiert. Funktionieren würde es auch ohne Überschreiben, aber viel langsamer</li>
</ul>
</li>
<li>
<p><strong>Folie 64</strong></p>
<ul>
<li>Korrektur: <code>addFirst()</code> ist bei ArrayList <script type="math/tex">O(n)</script>
</li>
<li><code>indexOf(p)</code> ist bei ArrayList nur <script type="math/tex">O(1)</script> wenn "p" Positions-Objekte sind </li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-10-iteratoren-trees">Vorlesung 10 - Iteratoren &amp; Trees</h2>
<h3 id="iterators">Iterators</h3>
<ul>
<li><strong>Iterator-Varianten</strong><ul>
<li>Snapshot-Iterator<ul>
<li>Vor dem Iterieren eine Kopie erstellen</li>
<li>
<script type="math/tex">O(n)</script>
</li>
</ul>
</li>
<li>Lazy-Iterator<ul>
<li>Direkt auf der Datenstruktur iterieren</li>
<li>Wenn Datenstruktur verändert wird, kann der Iterator unerwartet reagieren</li>
<li>Bei java api verwendet</li>
<li>Java Framework wirft exception bei <code>next()</code>, wenn Datenstruktur verändert wurde</li>
<li>Java hat Iterator.remove(), um das aktuelle Element zu löschen</li>
<li>
<script type="math/tex">O(1)</script>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Implementierung</strong><ul>
<li><code>NoSuchElementException</code><ul>
<li>Wenn <code>next()</code> false ergibt, aber <code>next()</code> aufgerufen wird</li>
</ul>
</li>
<li><code>UnsupportedOperationException</code><ul>
<li>Iterator hat remove() nicht implementiert, zb. wenn Liste mit <code>Array.asList()</code> erstellt wird (AbstractList)</li>
</ul>
</li>
<li><code>IllegalStateException</code><ul>
<li>Wenn zwei mal hintereinander <code>remove()</code> aufgerufen wird</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="trees">Trees</h3>
<p>Tress sind abstrakte, hierarchische Strukturen bestehend aus Knoten in Eltern-Kind Relationen</p>
<ul>
<li><strong>Eigenschaften</strong><ul>
<li>Internene Knoten: Knoten mit mind. 1 Child</li>
<li>Externer Knoten: Blattknoten (Leaf-Nodes), Knoten ohne Kinder</li>
<li>Tiefe: Anzahl Vorgänger</li>
<li>Höhe eines Knotens: Höhe im Baum von oben. Leaf-Nodes: 0</li>
<li>Höhe eines Baums: Höhe der Wurzel (Root)</li>
<li>Sibling: Geschwisterknoten</li>
</ul>
</li>
<li><strong>Baum-Traversierung</strong> (jeden Knoten "besuchen")<ul>
<li>Preorder: Jeder Knoten vor seinen Childs besuchen, wie der Ausdruck eines Dokuments</li>
<li>Postorder: Jeder Knoten wird nach seinen Children besucht<ul>
<li>Anwendung: Auswertung arithmetischer Ausdrücke: Jeder Aufruf liefert Wert des Unterbaums. Eine solche Traversierung ist das gleiche wie ein Stack-Rechner (Reverse Polnische Notation)</li>
</ul>
</li>
<li>Inorder: Von einem Knoten wird zuerst der linke Subtree besucht, dann der Knoten, und dann der rechte Subtree<ul>
<li>Anwendung: Graphische Darstellung eines Baumes (x= inorder Rang, y=Tiefe)</li>
<li>Anwendung: Ausgabe arithmetischer Ausdrücke. Operanden sind in den Blattknoten, Operatoren in den internen Knoten. Über jeden Subtree werden Klammern gesetzt</li>
</ul>
</li>
<li>Alle drei sind Spezialfälle der <em>Euler Tour</em> Traversierung. Darin wird jeder Knoten drei mal besucht. Von links (preoder), unten (inorder) und rechts (postorder)</li>
</ul>
</li>
<li><strong>Binäre Bäume</strong><ul>
<li>Haben pro Knoten ein geordnetes Paar von children (left, right)</li>
<li>Jeder Knoten hat (in einem echten Binärbaum) ein Sibling (ausser root)</li>
<li>Balancierter, "Echter" Binärbaum: Jeder Knoten hat genau zwei Children</li>
<li>Unbalanciert: Das "Gewicht" liegt auf einer Seite</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-11-trees-priority-queues">Vorlesung 11 - Trees &amp; Priority Queues</h2>
<h3 id="trees_1">Trees</h3>
<ul>
<li><strong>Template Method Pattern Euler Traversierung</strong><ul>
<li>visitExternal(), visitLeft(), visitRight() etc. sind in abstrakter Klasse leer</li>
<li>Die benötigten Methoden werden in konkreter Klasse überschrieben und "implementiert"</li>
</ul>
</li>
<li><strong>GoF = Gang of Four</strong><ul>
<li>Autoren des bekannten "Design Patterns" (1995)</li>
</ul>
</li>
</ul>
<h3 id="priority-queues">Priority Queues</h3>
<ul>
<li>Jeder Entry der Queue besteht aus einem Key-Value-Pair</li>
<li><code>removeMin()</code> entfernt jeweils das Element mit dem niedrigsten Key (= <em>höchste Priorität</em>)</li>
<li><strong>Comparator</strong><ul>
<li>allgemein: <code>compare(a, b) {return a - b;}</code></li>
</ul>
</li>
<li><strong>Folie 8</strong><ul>
<li>Hier wird nur der Key verwendet, Values bleiben immer null.</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vorlesung-12-heaps-adaptable-pq">Vorlesung 12 - Heaps &amp; Adaptable PQ</h2>
<h3 id="heaps">Heaps</h3>
<ul>
<li><strong>Folie 3</strong><ul>
<li>Der Heap wird in einem Binärbaum gespeichert</li>
<li>Der Key jedes Knoten ausser die Wurzel muss grösser sein als sein parent-Knoten</li>
<li>-&gt; Das kleinste Element ist der Root-Knoten</li>
</ul>
</li>
<li><strong>Folie 4</strong><ul>
<li>Alle Knoten bis h-1 sind gefüllt</li>
<li>Die letzte Ebene (tiefe h) wird von links her aufgefüllt</li>
<li>-&gt; Der letzte Knoten ist der weiteste Rechts auf Tiefe h</li>
<li>-&gt; h ist <script type="math/tex">\log_2 (n)</script> abgerundet</li>
</ul>
</li>
<li><strong>Folie 9</strong><ul>
<li>Die Bedingung für den Heap muss nur "upheap" geprüft werden, da Elemente immer von rechts eingefügt werden und der linke "Teilbaum" nie verändert werden muss</li>
</ul>
</li>
<li><strong>Folie 11</strong><ul>
<li>Es sind explizit <script type="math/tex">2\cdot\log_2 (n)</script> Vergleiche, da immer beide Children überprüft werden müssen</li>
</ul>
</li>
<li><strong>Folie 12</strong><ul>
<li>Die Priority-Queue mit einem Heap hat <script type="math/tex">O(\log n)</script> für insert() und removeMin(), was sie viel schneller macht als Insertion- bzw. Selection-Sort, die für jeweils eine Operation <script type="math/tex">O(n^2)</script> benötigen</li>
</ul>
</li>
</ul>
<h3 id="adaptable-pqs">Adaptable PQs</h3>
<ul>
<li><code>remove(e)</code>: Entfernt eine Entry aus und liefert sie zurück</li>
<li><code>replaceKey(e,k)</code>: Schlüssel der Entry e ersetzen und der alte Schlüssel zurück geben</li>
<li><code>replaceValue(e,v)</code>: Der Wert der Entry e ersetzen und der alte Wert zurück geben</li>
<li>"Location-Aware" Entries haben eine Referenz auf ihre Position in der Datenstruktur gespeichert, damit für den Zugriff nicht die ganze Struktur abgesucht werden muss</li>
</ul>
<hr />
<h2 id="vorlesung-13-maps-hash-tables">Vorlesung 13 - Maps &amp; Hash-Tables</h2>
<h3 id="maps">Maps</h3>
<p>Eine Map ist eine durchsuchbare Collection von Key-Value Entries. Pro Key wird nur <em>eine Entry</em> erlaubt.</p>
<ul>
<li><code>get(k)</code>: Value mit dem Key <code>k</code> zurückgeben, wenn nicht vorhanden <code>null</code></li>
<li><code>put(k, v)</code>: Neue Entry(k, v) hinzufügen (Rückgabe <code>null</code>), wenn schon vorhanden, wird Value <code>v</code> ersetzt und der alte Value zurück gegeben</li>
<li><code>remove(k)</code>: Entry mit Key <code>k</code> entfernen und zurück geben. Wenn nicht vorhanden <code>null</code></li>
<li><code>values()</code>: Collection mit allen Werten (Duplikate möglich, da unterschiedliche Keys gleiche Values haben können)</li>
<li>Implementierung mit Verketteter Liste<ul>
<li>
<script type="math/tex">O(n)</script> für <code>remove()</code> und <code>put()</code> und <code>get()</code></li>
<li>Mit Sentinel Trick nur die hälfte der Abfrage möglich<ul>
<li>Am Ende der Liste einen Eintrag mit gesuchtem Key eintragen</li>
<li>Man muss dann nicht jedes Mal fragen, ob man am Ende der Liste ist, sondern nur, ob der Key stimmt</li>
<li>Immer noch <script type="math/tex">O(n)</script>, aber Schritte werden ca. halbiert</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="hash-table">Hash-Table</h3>
<ul>
<li>Hash-Funktion bildet Keys auf Integer in bestimmten Intervall ab<ul>
<li>Die Werte sollen möglichst gestreut werden</li>
<li><code>hashCode()</code> gibt irgendeinen Integer zurück, der dann noch in das Intervall "gemappt" werden muss</li>
<li><code>Object</code> in Java gibt eine Integer Adresse des Objekts aus dem Heap zurück</li>
<li>Wert wird als Integer angeschaut (z.B. als Bits bei float)</li>
<li>Sonst mit Komponentensumme: Wert unterteilen in Komponenten fixer Länge und die Komponenten addieren (overflow ignorieren)</li>
<li>Polynom-Akkumulation: Komponenten als Koeffizienten eines Polynoms betrachten und mit einer konstanten Primzahl <script type="math/tex">z</script> ausrechnen. Wird z.B. bei Strings verwendet. Bsp: <script type="math/tex">"ab" \rightarrow 98 \cdot 31^0 + 97 \cdot 31^1 = 3105</script>
</li>
</ul>
</li>
<li>Hashtable Grösse: Primzahl wählen (bessere Streuung)</li>
<li>offene Adressierung: Man bleibt bei Kollisionen in der Tabelle<ul>
<li>Linear Probing: Wenn Kollision, suche nächster freier Platz</li>
<li>Löschen: <ul>
<li>Problem, weil get() dann evtl. nicht mehr funktioniert</li>
<li>Lösung: Datensätze werden nicht gelöscht, sondern nur als gelöscht markiert (DEFUNCT Entry)</li>
</ul>
</li>
</ul>
</li>
<li>geschlossene Adressierung: Separte Datenstruktur für Kollisionen (z.B. linked list)</li>
<li>doppeltes Hashing: Zusätzliche Hash-Funktion verwenden</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../an2/" class="btn btn-neutral float-right" title="An2">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../.." class="btn btn-neutral" title="Home"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/Excape/hsr-docs" class="icon icon-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../.." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../an2/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
